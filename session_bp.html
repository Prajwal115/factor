<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BP Session</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>
<style>
      @import url('https://fonts.googleapis.com/css2?family=DM+Mono:ital,wght@0,300;0,400;0,500;1,300;1,400;1,500&family=DM+Sans:ital,opsz,wght@0,9..40,100..1000;1,9..40,100..1000&display=swap');

    body {
        margin: 0;
        padding: 0;
        overflow-x: hidden;
    }

    .main {
        background: black;
        height: 700px;
    }

    .footer {
        position: fixed;
        bottom: 0;
        width: 100%;
        background-color: black;
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        align-items: center;
        font-family: 'DM Sans', sans-serif;
        font-size: 14px;
        padding: 20px 60px;
        padding-right: 60px;
        color: rgba(255, 255, 255, 0.46);
        z-index: 10;
        gap: 16px;
    }

    .footer-link {
        color: rgba(255, 255, 255, 0.46);
        text-decoration: none;
        font-weight: 400;
        transition: 0.3s ease;
        margin-left: 16px;
    }
    .footer-link:first-child {
        margin-left: 0;
    }
    .footer-link:hover {
        color: white;
        transition: 0.3s ease;
    }



.top-bar {
    background-color: rgba(255, 255, 255, 0.05);
    height: 80px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 60px;
}

.topic-text {
    color: white;
    font-family: 'DM Sans', sans-serif;
    font-size: 17px;
    font-weight: 300;
}
.topic-text strong{
    font-weight: 400;
}
.start-button {
    background: transparent;
    border: 1px solid rgba(142, 142, 142, 0.56);
    color: white;
    font-family: 'DM Sans', sans-serif;
    font-size: 15px;
    padding: 10px 20px;
    border-radius: 12px;
    cursor: pointer;
    transition: 0.3s ease;
}

.start-button:hover {
    background: white;
    color: black;
    border-radius: 23px;
}

.debate-boxes {
    padding: 40px 60px;
    display: flex;
    margin-top: 20px;
    flex-direction: column;
    gap: 30px;
}

.row {
    display: flex;
    justify-content: space-between;
    gap: 30px;
}

.debate-box {
    flex: 1;
    min-width: 120px;
    height: 100px;
    border: 1px solid rgb(156, 156, 156);
    border-radius: 12px;
    background: transparent;
    color: white;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    font-family: 'DM Sans', sans-serif;
    text-align: center;
    padding: 10px;
}

    .debate-role {
        font-size: 16px;
        font-weight: 700;
    }

    .debate-team {
        font-size: 14px;
        font-weight: 600;
        opacity: 0.7;
        margin-top: 0px;
    }
    .controls {
        display: flex;
        justify-content: center;
        align-items: center;
        margin-top: 30px;
        gap: 20px;
    }

    .control-button {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 10px 20px;
        background: transparent;
        color: white;
        font-family: 'DM Sans', sans-serif;
        font-size: 14px;
        border: 1px solid;
        border-radius: 8px;
        cursor: pointer;
    }

    .speak-button {
        border-color: rgb(114, 114, 114);
    }

    .alerts-button {
        border-color: #ffcaca78;
        color:#FFCACA;
    }

    .control-button .material-icons {
        font-size: 18px;
    }

    .time-display {
        padding: 10px 80px;
        background-color: #121212;
        color: white;
        font-family: 'DM Sans', sans-serif;
        font-size: 14px;
        border-radius: 8px;
        border: 1px solid rgb(114, 114, 114);
    }

  .subtitles {
      position: fixed;
      bottom: 100px;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 4px;
      font-family: 'DM Sans', sans-serif;
      z-index: 10;
      padding-left: 40px;
  }

  .subtitle-line {
      background: rgba(0, 0, 0, 0.6);
      padding: 2px 16px;
      border-radius: 8px;
      color: white;
      font-size: 18px;
      display: flex;
      gap: 6px;
  }

  .role-tag {
      font-weight: 600;
  }
</style>

<body>
    <div class="main">
        <div class="top-bar">
            <div class="topic-text" id="topicDisplay">Topic:</div>
            <button class="start-button">Start Session</button>
        </div>
        <div class="controls">
            <button class="control-button speak-button"><span class="material-icons">mic</span>Speak</button>
            <div class="time-display">Time Elapsed:</div>
            <button class="control-button alerts-button"><span class="material-icons">notifications_active</span>Alerts</button>
        </div>
        <div class="debate-boxes">
            <div class="row">
                <div class="debate-box">
                    <div class="debate-role">Prime Minister</div>
                    <div class="debate-team">Opening Govt.</div>
                </div>
                <div class="debate-box">
                    <div class="debate-role">Deputy Prime Minister</div>
                    <div class="debate-team">Opening Govt.</div>
                </div>
                <div class="debate-box">
                    <div class="debate-role">Member of Government</div>
                    <div class="debate-team">Closing Govt.</div>
                </div>
                <div class="debate-box">
                    <div class="debate-role">Government Whip</div>
                    <div class="debate-team">Closing Govt.</div>
                </div>
            </div>
            <div class="row">
                <div class="debate-box">
                    <div class="debate-role">Leader of Opposition</div>
                    <div class="debate-team">Opening Opp.</div>
                </div>
                <div class="debate-box">
                    <div class="debate-role">Deputy Leader of Opp.</div>
                    <div class="debate-team">Opening Opp.</div>
                </div>
                <div class="debate-box">
                    <div class="debate-role">Member of Opp.</div>
                    <div class="debate-team">Closing Opp.</div>
                </div>
                <div class="debate-box">
                    <div class="debate-role">Opposition Whip</div>
                    <div class="debate-team">Closing Opp.</div>
                </div>
            </div>
        </div>
        <div class="subtitles">
            <div class="subtitle-line">
                <span class="role-tag govt-role">PM:</span>
                <span class="subtitle-text">Good evening to all of you.</span>
            </div>
            <div class="subtitle-line">
                <span class="role-tag opp-role">LO:</span>
                <span class="subtitle-text">We strongly oppose the motion.</span>
            </div>
        </div>
        <footer class="footer">
            <span>Powered by AI. Some features in beta. Expect brilliance, with the occasional flaw.</span>
        </footer>
    </div>
<script>
  const sessionData = JSON.parse(localStorage.getItem("sessionData"));
  const topic = sessionData?.topic || "N/A";
  document.getElementById("topicDisplay").textContent = `Topic: ${topic}`;

  const startButton = document.querySelector(".start-button");
  const timeDisplay = document.querySelector(".time-display");
  let timerInterval = null;
  let startTime = null;
  let sessionStarted = false;

  startButton.addEventListener("click", () => {
    if (startButton.textContent === "Start Session") {
      startButton.textContent = "End Session";
      startTime = Date.now();
      sessionStarted = true;
      localStorage.removeItem("lastGeminiReply");

      timerInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
        const seconds = String(elapsed % 60).padStart(2, '0');
        timeDisplay.textContent = `Time Elapsed: ${minutes}:${seconds}`;
      }, 1000);

      updateTurnHighlight(); // refresh button states
    } else {
      startButton.textContent = "Start Session";
      clearInterval(timerInterval);
      sessionStarted = false;

      updateTurnHighlight(); // refresh button states
    }
  });
</script>
<script>
  const govtRoles = ["prime minister", "deputy prime minister", "member of government", "government whip"];
  const oppRoles = ["leader of opposition", "deputy leader of opp.", "member of opp.", "opposition whip"];

  document.querySelectorAll(".debate-box").forEach(box => {
      const roleEl = box.querySelector(".debate-role");
      const role = roleEl?.textContent?.trim().toLowerCase();

      if (govtRoles.includes(role)) {
          roleEl.style.color = "#C1FEFF"; // blue for govt
      } else if (oppRoles.includes(role)) {
          roleEl.style.color = "#FFA8A8"; // red for opp
      }
  });

  const userTeam = sessionData?.speaker_team?.toLowerCase();

  const highlightRoles = {
      "opening govt.": ["prime minister", "deputy prime minister"],
      "closing govt.": ["member of government", "government whip"],
      "opening opp.": ["leader of opposition", "deputy leader of opp."],
      "closing opp.": ["member of opp.", "opposition whip"]
  };

  const userRoles = highlightRoles[userTeam] || [];

  document.querySelectorAll(".debate-box").forEach(box => {
      const roleEl = box.querySelector(".debate-role");
      const role = roleEl?.textContent?.trim().toLowerCase();

      if (userRoles.includes(role)) {
          box.style.border = "2px solid #C1FFC7";// green border
          roleEl.style.color="#C1FFC7";

      }
  });
</script>
<script>
const speakButton = document.querySelector(".speak-button");
let isSpeaking = false;
let mediaRecorder;
let audioChunks = [];
let aiLock = false;

speakButton.addEventListener("click", async () => {
    if (!isSpeaking) {
        speakButton.innerHTML = `<span class="material-icons">stop</span>Stop`;
        isSpeaking = true;

        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream);
            mediaRecorder.start();
            audioChunks = [];

            mediaRecorder.addEventListener("dataavailable", event => {
                audioChunks.push(event.data);
            });

            mediaRecorder.addEventListener("stop", () => {
                // Handles upload, Gemini prompting, and TTS for all roles including PM, DPM, etc.
                // Only proceed if lastAudio is not playing or has ended
                if (!window.lastAudio || window.lastAudio.ended) {
                    const audioBlob = new Blob(audioChunks, { type: "audio/webm" });
                    const formData = new FormData();

                    // Ensure username and session_id are in localStorage
                    const sessionId = localStorage.getItem("session_id");
                    const username = localStorage.getItem("username");
                    const role = speakingOrder[currentTurn];

                    formData.append("audio", audioBlob, `${role}.webm`);
                    formData.append("session_id", sessionId);
                    formData.append("username", username);
                    formData.append("role", role);

                    fetch("/upload-audio", {
                        method: "POST",
                        body: formData
                    })
                    .then(response => response.json())
                    .then(data => {
                        console.log("Audio uploaded successfully:", data);
                        console.log("Transcript:", data.transcript);
                        localStorage.setItem("lastGeminiReply", data.transcript);
                        updateTurnHighlight();

                        // Send all necessary localStorage data to FastAPI
                        const pepTalk = JSON.parse(localStorage.getItem("pepTalk"));
                        const sessionData = JSON.parse(localStorage.getItem("sessionData"));
                        const username = localStorage.getItem("username");
                        const session_id = localStorage.getItem("session_id");

                        const geminiPayload = {
                            transcript: data.transcript,
                            session_id: session_id,
                            username: username,
                            topic: sessionData.topic,
                            side: sessionData.side,
                            speaker_team: sessionData.speaker_team,
                            difficulty: sessionData.difficulty,
                            pep_talk: pepTalk,
                            role: role
                        };

                        // Gemini and TTS logic for user roles is now handled by the AI turn, not here.
                    })
                    .catch(error => {
                        console.error("Upload failed:", error);
                    });
                } else {
                    console.warn("Previous audio not finished. Skipping request.");
                }
            });
        } catch (err) {
            console.error("Error accessing mic:", err);
        }

    } else {
        speakButton.innerHTML = `<span class="material-icons">mic</span>Speak`;
        isSpeaking = false;

        if (mediaRecorder && mediaRecorder.state !== "inactive") {
            mediaRecorder.stop();
        }

        // Advance turn after speaking
        currentTurn++;
        if (currentTurn < speakingOrder.length) {
            // updateTurnHighlight(); // (Removed to avoid triggering it prematurely)
        }
    }
});

const speakingOrder = [
    "prime minister",
    "leader of opposition",
    "deputy prime minister",
    "deputy leader of opp.",
    "member of government",
    "member of opp.",
    "government whip",
    "opposition whip"
];

let currentTurn = 0;
let isAIProcessing = false;
let isAudioPlaying = false;
let aiTurnLock = false;

function updateTurnHighlight() {
    document.querySelectorAll(".debate-box").forEach(box => {
        const roleEl = box.querySelector(".debate-role");
        const role = roleEl?.textContent?.trim().toLowerCase();

        if (speakingOrder[currentTurn] === role) {
            if (userRoles.includes(role)) {
                // User's own turn — green background, black text
                box.style.background = "#C1FFC7";
                roleEl.style.color = "black";
                box.style.color = "black";
                box.style.border = "2px solid #C1FFC7";
            } else if (govtRoles.includes(role)) {
                // Other govt role's turn — blue background, black text
                box.style.background = "#C1FEFF";
                roleEl.style.color = "black";
                box.style.color = "black";
                box.style.border = "2px solid #C1FEFF";
            } else if (oppRoles.includes(role)) {
                // Other opp role's turn — red background, black text
                box.style.background = "#FFA8A8";
                roleEl.style.color = "black";
                box.style.color = "black";
                box.style.border = "2px solid #FFA8A8";
            }
        } else {
            // Reset style for non-current speakers
            box.style.background = "transparent";
            box.style.color = "white";

            if (userRoles.includes(role)) {
                box.style.border = "2px solid #C1FFC7";
                roleEl.style.color = "#C1FFC7";
            } else if (govtRoles.includes(role)) {
                box.style.border = "1px solid rgb(156, 156, 156)";
                roleEl.style.color = "#C1FEFF";
            } else if (oppRoles.includes(role)) {
                box.style.border = "1px solid rgb(156, 156, 156)";
                roleEl.style.color = "#FFA8A8";
            }
        }
    });

    // Disable speak button if session not started or if it's not the user's turn
    const currentRole = speakingOrder[currentTurn];
    if (!sessionStarted || !userRoles.includes(currentRole)) {
        speakButton.disabled = true;
        speakButton.style.opacity = 0.5;
        speakButton.style.cursor = "not-allowed";

        if (
            sessionStarted &&
            !userRoles.includes(currentRole) &&
            !isAIProcessing &&
            !aiTurnLock &&
            !isAudioPlaying
        ) {
            handleAIRole(currentRole);
        }
    } else {
        speakButton.disabled = false;
        speakButton.style.opacity = 1;
        speakButton.style.cursor = "pointer";
    }
}

function handleAIRole(role) {
    // Safeguard against double requests
    if (isAIProcessing) {
        console.warn("Duplicate Gemini call blocked.");
        return;
    }
    if (isAudioPlaying || aiTurnLock) {
        console.warn("AI is busy, audio is playing, or lock is set. Skipping duplicate call.", {
            isAIProcessing,
            isAudioPlaying,
            aiTurnLock
        });
        return;
    }
    aiTurnLock = true;
    isAIProcessing = true;
    console.log("Sending Gemini request for role:", role);

    const sessionId = localStorage.getItem("session_id");
    const username = localStorage.getItem("username");
    const pepTalk = JSON.parse(localStorage.getItem("pepTalk"));
    const sessionData = JSON.parse(localStorage.getItem("sessionData"));

    console.log("Transcript being sent to Gemini:", localStorage.getItem("lastGeminiReply"));
    const geminiPayload = {
        transcript: localStorage.getItem("lastGeminiReply") || "",
        session_id: sessionId,
        username: username,
        topic: sessionData.topic,
        side: sessionData.side,
        speaker_team: sessionData.speaker_team,
        difficulty: sessionData.difficulty,
        pep_talk: pepTalk,
        role: role
    };

    fetch("/send-to-gemini", {
        method: "POST",
        headers: {
            "Content-Type": "application/json"
        },
        body: JSON.stringify(geminiPayload)
    })
    .then(response => response.json())
    .then(geminiData => {
        localStorage.setItem("lastGeminiReply", geminiData.reply);
        console.log("Gemini reply:", geminiData.reply);
        if (
            !geminiData.reply ||
            geminiData.reply.length < 20 ||
            geminiData.reply.toLowerCase().includes("skipping invalid") ||
            geminiData.reply.toLowerCase().includes("s k p p")
        ) {
            console.warn("Gemini reply is too short or invalid. Skipping playback. Reply:", geminiData.reply);
            aiTurnLock = false;
            isAIProcessing = false;
            // Still proceed to next role
            setTimeout(() => {
                currentTurn++;
                console.log("Skipping bad Gemini reply. Proceeding to next role:", speakingOrder[currentTurn]);
                if (currentTurn < speakingOrder.length) {
                    updateTurnHighlight();
                }
            }, 100);
            return;
        }

        fetch("/text-to-speech", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                text: geminiData.reply,
                session_id: sessionId,
                username: username,
                filename: `tts_${role.replace(/\s+/g, "_")}_${Date.now()}.mp3`
            })
        })
        .then(response => response.json())
        .then(data => {
            // Defensive check for undefined or malformed audio path
            if (!data.audio_path || typeof data.audio_path !== "string" || data.audio_path.includes("undefined")) {
                console.warn("Invalid or undefined audio path from TTS. Skipping playback.");
                isAudioPlaying = false;
                isAIProcessing = false;
                aiTurnLock = false;
                // Do NOT increment turn or call updateTurnHighlight()
                return;
            }
            // Use audio path without cache-busting timestamp
            const uniqueAudioPath = `/${data.audio_path}`;
            console.log("Final audio path to play:", uniqueAudioPath);
            const audio = new Audio();
            audio.src = uniqueAudioPath;
            audio.load();
            audio.onended = () => {
                console.log("Audio ended for:", role);
                isAudioPlaying = false;
                isAIProcessing = false;
                aiTurnLock = false;
                setTimeout(() => {
                    currentTurn++;
                    console.log("Proceeding to next role:", speakingOrder[currentTurn]);
                    if (currentTurn < speakingOrder.length) {
                        updateTurnHighlight();
                    }
                }, 100);
            };
            audio.play().then(() => {
                isAudioPlaying = true;
            })
            .catch(error => {
                console.error("Playback failed:", error);
                isAudioPlaying = false;
                isAIProcessing = false;
                aiTurnLock = false;
                setTimeout(() => {
                    console.log("Audio failed. Proceeding to next role:", speakingOrder[currentTurn]);
                    if (currentTurn < speakingOrder.length) {
                        updateTurnHighlight();
                    }
                }, 100);
            });
        })
        .catch(error => {
            console.error("TTS fetch failed:", error);
            aiTurnLock = false;
            isAIProcessing = false;
            currentTurn++;
        });
    })
    .catch(error => {
        console.error("Gemini fetch failed:", error);
        aiTurnLock = false;
        isAIProcessing = false;
        currentTurn++;
    });
}

// Initial call
updateTurnHighlight();

document.querySelectorAll(".subtitle-line .role-tag").forEach(tag => {
    const roleInitial = tag.textContent.trim().toLowerCase().replace(":", "");
    const roleMap = {
        "pm": "prime minister",
        "dpm": "deputy prime minister",
        "mg": "member of government",
        "gw": "government whip",
        "lo": "leader of opposition",
        "dlo": "deputy leader of opp.",
        "mo": "member of opp.",
        "ow": "opposition whip"
    };

    const fullRole = roleMap[roleInitial];
    if (!fullRole) return;

    if (userRoles.includes(fullRole)) {
        tag.style.color = "#C1FFC7";
    } else if (govtRoles.includes(fullRole)) {
        tag.style.color = "#C1FEFF";
    } else if (oppRoles.includes(fullRole)) {
        tag.style.color = "#FFA8A8";
    }
});

</script>
</body>

</html>
